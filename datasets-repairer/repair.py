#!/usr/bin/env python3
"""
Command-Line Interface for LLM-generated Datasets Repairer
==========================================================

Main CLI for repairing corrupted XML datasets generated by LLMs.
Provides comprehensive analysis, repair, and logging functionality.
"""

import os
import sys
import glob
import argparse
from typing import List, Dict
from pathlib import Path

# Add current directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from repair_engine import XMLRepairTool, RepairStats
from corruption_detector import CorruptionDetector

def main():
    parser = argparse.ArgumentParser(
        description="LLM-generated Datasets Repairer - Fix corrupted XML datasets",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
üõ†Ô∏è  LLM-GENERATED DATASETS REPAIRER

DESCRIPTION:
    Detects and repairs corrupted XML datasets generated by Large Language Models.
    Common LLM corruption patterns include split tags, malformed attributes, 
    missing spaces, orphaned content, and structural inconsistencies.

EXAMPLES:
    %(prog)s --directory /path/to/xml/files
    %(prog)s --file /path/to/corrupted.xml
    %(prog)s --directory /path/to/xml/files --dry-run
    %(prog)s --directory /path/to/xml/files --force
    %(prog)s --directory /path/to/xml/files --analyze-only --verbose

OUTPUT FILES:
    ‚Ä¢ filename.xml.original_backup  - Backup of original file
    ‚Ä¢ filename_repair_log.txt       - Detailed repair log with before/after

SAFETY FEATURES:
    ‚Ä¢ Automatic backups always created (unless --no-backup)
    ‚Ä¢ Validation of repairs using XML parser
    ‚Ä¢ Detailed logging of all changes made
    ‚Ä¢ Dry-run mode to preview changes

For complete documentation, see README.md
"""
    )
    
    # File/directory selection
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--directory', '-d', type=str,
                      help='Directory containing XML files to repair')
    group.add_argument('--file', '-f', type=str,
                      help='Repair specific file instead of directory')
    
    # Operation modes
    parser.add_argument('--dry-run', action='store_true',
                       help='Show what would be repaired without making changes')
    parser.add_argument('--force', action='store_true', 
                       help='Repair all files, even if they appear valid')
    parser.add_argument('--no-backup', action='store_true',
                       help='Skip creating backup files (not recommended)')
    
    # Analysis options
    parser.add_argument('--analyze-only', action='store_true',
                       help='Only analyze corruption patterns, do not repair')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Show detailed output')
    
    args = parser.parse_args()
    
    # Initialize tools
    repair_tool = XMLRepairTool()
    detector = CorruptionDetector()
    
    print("üõ†Ô∏è  LLM-GENERATED DATASETS REPAIRER")
    print("=" * 60)
    
    # Get list of files to process
    xml_files = get_xml_files(args)
    if not xml_files:
        print("‚ùå No XML files found")
        return 1
    
    print(f"üìÅ Processing {len(xml_files)} XML files...")
    if args.dry_run:
        print("üîç DRY RUN MODE - No changes will be made")
    elif args.analyze_only:
        print("üìä ANALYSIS MODE - No repairs will be performed")
    print()
    
    # Process files
    if args.analyze_only:
        return analyze_files(xml_files, detector, args.verbose)
    else:
        return repair_files(xml_files, repair_tool, detector, args)

def get_xml_files(args) -> List[str]:
    """Get list of XML files to process based on arguments"""
    if args.file:
        if not os.path.exists(args.file):
            print(f"‚ùå File not found: {args.file}")
            return []
        if not args.file.lower().endswith('.xml'):
            print(f"‚ùå File is not an XML file: {args.file}")
            return []
        return [args.file]
    
    if args.directory:
        if not os.path.exists(args.directory):
            print(f"‚ùå Directory not found: {args.directory}")
            return []
        
        xml_files = glob.glob(os.path.join(args.directory, "*.xml"))
        return sorted(xml_files)
    
    return []

def analyze_files(xml_files: List[str], detector: CorruptionDetector, verbose: bool) -> int:
    """Analyze files for corruption without repairing"""
    print("üîç CORRUPTION ANALYSIS")
    print("-" * 40)
    
    reports = detector.batch_analyze(xml_files)
    
    for file_path, report in reports.items():
        filename = os.path.basename(file_path)
        print(f"üìÑ {filename}")
        
        if report.is_valid_xml:
            print(f"  ‚úÖ Valid XML")
        else:
            print(f"  ‚ùå Invalid XML")
        
        print(f"  üìä Issues: {report.total_issues}")
        print(f"  üéØ Severity: {report.severity_level}")
        print(f"  üîß Repairability: {report.repairability}")
        
        if verbose and report.total_issues > 0:
            print(f"  üìã Corruption patterns:")
            for pattern, count in report.corruption_patterns.items():
                if count > 0:
                    print(f"    - {pattern}: {count}")
            
            if report.sample_errors:
                print(f"  üîç Sample errors:")
                for error in report.sample_errors:
                    print(f"    - {error}")
        
        print()
    
    # Summary statistics
    summary = detector.get_summary_stats(reports)
    print("=" * 60)
    print("üìä ANALYSIS SUMMARY")
    print("=" * 60)
    print(f"Total files: {summary['total_files']}")
    print(f"Valid XML files: {summary['valid_xml_files']}")
    print(f"Corrupted files: {summary['corrupted_files']}")
    print(f"Total issues: {summary['total_issues']}")
    print(f"Average issues per file: {summary['average_issues_per_file']:.1f}")
    
    if summary['severity_distribution']:
        print(f"\nSeverity distribution:")
        for severity, count in summary['severity_distribution'].items():
            print(f"  {severity}: {count}")
    
    if summary['repairability_distribution']:
        print(f"\nRepairability distribution:")
        for repairability, count in summary['repairability_distribution'].items():
            print(f"  {repairability}: {count}")
    
    return 0

def repair_files(xml_files: List[str], repair_tool: XMLRepairTool, 
                detector: CorruptionDetector, args) -> int:
    """Repair files and show results"""
    
    stats = {
        'total_files': len(xml_files),
        'healthy_files': 0,
        'repaired_files': 0,
        'failed_files': 0,
        'total_issues_fixed': 0,
        'skipped_files': 0
    }
    
    for xml_file in xml_files:
        filename = os.path.basename(xml_file)
        print(f"üîç Processing {filename}...")
        
        # Quick analysis first
        if not args.dry_run:
            report = detector.analyze_file(xml_file)
            
            # Skip if file is already valid and not forcing
            if report.is_valid_xml and not args.force:
                print(f"  ‚úÖ File is already well-formed")
                stats['healthy_files'] += 1
                continue
            elif report.is_valid_xml and args.force:
                print(f"  ‚ÑπÔ∏è  File is valid but --force specified")
        
        if args.dry_run:
            # Dry run analysis
            report = detector.analyze_file(xml_file)
            total_issues = report.total_issues
            
            print(f"  üìä Issues found: {total_issues}")
            if args.verbose and total_issues > 0:
                for pattern, count in report.corruption_patterns.items():
                    if count > 0:
                        print(f"    - {pattern}: {count}")
            
            if total_issues > 0:
                stats['total_issues_fixed'] += total_issues
                print(f"  üîß Would repair {total_issues} issues")
                print(f"  üéØ Repairability: {report.repairability}")
            
            continue
        
        # Perform actual repair
        try:
            repair_result = repair_tool.repair_file(
                xml_file, 
                create_backup=not args.no_backup
            )
            
            if repair_result.success:
                print(f"  ‚úÖ Successfully repaired!")
                stats['repaired_files'] += 1
            else:
                print(f"  ‚ùå Repair failed")
                stats['failed_files'] += 1
            
            if repair_result.repair_actions:
                issues_count = sum(repair_result.corruption_patterns.values())
                actions_count = len(repair_result.repair_actions)
                
                print(f"  üìä Issues detected: {issues_count}")
                print(f"  üîß Repair actions: {actions_count}")
                print(f"  üìà Size: {repair_result.original_size:,} ‚Üí {repair_result.repaired_size:,} chars")
                
                if repair_result.backup_path:
                    print(f"  üíæ Backup: {os.path.basename(repair_result.backup_path)}")
                
                if repair_result.log_path:
                    print(f"  üìÑ Log: {os.path.basename(repair_result.log_path)}")
                
                # Show details for problematic files
                if args.verbose or not repair_result.success or issues_count > 10:
                    print("  üìã Actions taken:")
                    for action in repair_result.repair_actions[:3]:  # Show first 3 actions
                        print(f"    - {action.description}")
                    if len(repair_result.repair_actions) > 3:
                        print(f"    ... and {len(repair_result.repair_actions) - 3} more")
                
                stats['total_issues_fixed'] += issues_count
            else:
                print(f"  ‚ÑπÔ∏è  No issues found or no repairs needed")
                stats['healthy_files'] += 1
        
        except Exception as e:
            print(f"  ‚ùå Error processing file: {e}")
            stats['failed_files'] += 1
        
        print()
    
    # Final summary
    print("=" * 60)
    print("üìä REPAIR SUMMARY")
    print("=" * 60)
    
    if args.dry_run:
        print("üîç DRY RUN RESULTS:")
        print(f"Files analyzed: {stats['total_files']}")
        print(f"Total issues that would be fixed: {stats['total_issues_fixed']}")
    else:
        print(f"Total files processed: {stats['total_files']}")
        print(f"Already healthy: {stats['healthy_files']}")
        print(f"Successfully repaired: {stats['repaired_files']}")
        print(f"Failed repairs: {stats['failed_files']}")
        print(f"Total issues fixed: {stats['total_issues_fixed']}")
        
        success_rate = ((stats['healthy_files'] + stats['repaired_files']) / stats['total_files']) * 100
        print(f"Overall success rate: {success_rate:.1f}%")
        
        if stats['failed_files'] == 0:
            print("\nüéâ All XML files are now valid and corruption-free!")
            print("\nüìù Next steps:")
            print("  ‚Ä¢ Review repair logs for detailed changes")
            print("  ‚Ä¢ Validate datasets work with your experiments")
            print("  ‚Ä¢ Consider keeping backup files for safety")
            return 0
        else:
            print(f"\n‚ö†Ô∏è  {stats['failed_files']} files still need attention")
            print("\nüí° For failed files:")
            print("  ‚Ä¢ Check repair logs for detailed error information")
            print("  ‚Ä¢ Consider manual inspection of severely corrupted files")
            print("  ‚Ä¢ Some files may need regeneration from LLM")
            return 1

if __name__ == "__main__":
    try:
        exit_code = main()
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Operation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {e}")
        if os.getenv('DEBUG'):
            import traceback
            traceback.print_exc()
        sys.exit(1)