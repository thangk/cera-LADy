"""
Core XML Repair Engine
=====================

Main repair logic for fixing corrupted XML files generated by LLMs.
Handles various corruption patterns with detailed tracking and logging.
"""

import os
import re
import xml.etree.ElementTree as ET
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class RepairAction:
    """Represents a single repair action with before/after state"""
    line_number: Optional[int]
    action_type: str
    before: str
    after: str
    description: str

@dataclass
class RepairStats:
    """Statistics and results from a repair operation"""
    original_size: int
    repaired_size: int
    corruption_patterns: Dict[str, int]
    repair_actions: List[RepairAction]
    success: bool
    backup_path: Optional[str]
    log_path: Optional[str]

class XMLRepairTool:
    """
    Comprehensive XML repair tool for LLM-generated datasets.
    
    Handles various corruption patterns:
    - Split closing tags (</Opi + nions>)
    - Malformed opinion tags (</Opinces>, </O-pinions>, etc.)
    - Missing attribute spaces (from="0"to="0")
    - Orphaned closing tags
    - Structural inconsistencies
    - Invalid XML characters
    """
    
    def __init__(self):
        self.repair_patterns = {
            'split_closing_tags': 0,
            'malformed_opinions': 0,
            'missing_attributes': 0,
            'orphaned_tags': 0,
            'structural_issues': 0,
            'encoding_issues': 0,
            'invalid_characters': 0
        }
    
    def detect_corruption_patterns(self, content: str) -> Dict[str, int]:
        """Comprehensive corruption pattern detection"""
        patterns = {}
        
        # Split closing tags
        patterns['split_closing_tags'] = len(re.findall(r'</\w+$', content, re.MULTILINE))
        
        # Malformed opinion tags - specific malformed patterns only
        # NOTE: Valid tags are </Opinion> and </Opinions> - do NOT count these as malformed
        malformed_opinion_patterns = [
            r'</O-pinions>',          # Hyphenated O-pinions
            r'</Opinces>',            # Typo: Opinces 
            r'</Opinionss>',          # Double s: Opinionss
            r'</Opin>',               # Truncated: Opin
            r'</Opini>',              # Truncated: Opini
            r'</Opinio>',             # Truncated: Opinio
        ]
        patterns['malformed_opinions'] = sum(
            len(re.findall(pattern, content)) for pattern in malformed_opinion_patterns
        )
        
        # Missing attribute spaces
        patterns['missing_spaces'] = len(re.findall(r'="[^"]*"[a-zA-Z]', content))
        
        # Orphaned closing tags - only detect tags that appear without proper opening context
        # NOTE: This should only detect truly orphaned tags, not valid closing tags
        orphaned_patterns = []  # Removed overly broad patterns that flag valid XML structure
        patterns['orphaned_tags'] = sum(
            len(re.findall(pattern, content, re.MULTILINE)) for pattern in orphaned_patterns
        )
        
        # Unmatched sentence tags
        opening_sentences = len(re.findall(r'<sentence[^>]*>', content))
        closing_sentences = len(re.findall(r'</sentence>', content))
        patterns['unmatched_sentences'] = abs(opening_sentences - closing_sentences)
        
        # Invalid XML characters
        patterns['invalid_characters'] = len(re.findall(r'[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]', content))
        
        # Malformed attributes
        patterns['malformed_attributes'] = len(re.findall(r' a category=', content))
        
        return patterns
    
    def fix_basic_corruption(self, content: str) -> Tuple[str, List[RepairAction]]:
        """Fix basic corruption patterns with detailed tracking"""
        actions = []
        lines = content.splitlines()
        modified_lines = []
        
        i = 0
        while i < len(lines):
            line = lines[i]
            original_line = line
            line_modified = False
            
            # Check for split closing tags (</Opi + next line with nions>)
            if line.rstrip().endswith('</Opi') and i + 1 < len(lines):
                next_line = lines[i + 1].strip()
                if next_line == 'nions>':
                    # Merge the split tag
                    fixed_line = line.rstrip()[:-5] + '</Opinions>'
                    actions.append(RepairAction(
                        line_number=i + 1,
                        action_type="Fix split closing tag",
                        before=f"{line}\n{lines[i + 1]}",
                        after=fixed_line,
                        description="Merged split </Opinions> tag"
                    ))
                    modified_lines.append(fixed_line)
                    i += 2  # Skip the next line
                    continue
            
            # Fix incomplete closing tags
            if line.rstrip().endswith('</Opi'):
                fixed_line = line.rstrip()[:-5] + '</Opinions>'
                actions.append(RepairAction(
                    line_number=i + 1,
                    action_type="Fix incomplete closing tag",
                    before=line,
                    after=fixed_line,
                    description="Completed incomplete </Opinions> tag"
                ))
                line = fixed_line
                line_modified = True
            
            # Remove standalone continuation lines
            if line.strip() == 'nions>':
                actions.append(RepairAction(
                    line_number=i + 1,
                    action_type="Remove orphaned continuation",
                    before=line,
                    after="[REMOVED]",
                    description="Removed orphaned tag continuation"
                ))
                i += 1
                continue
            
            # Fix malformed opinion closing tags
            malformed_patterns = [
                (r'</O-pinions>', '</Opinions>', "Fixed hyphenated closing tag"),
                (r'</Opinces>', '</Opinions>', "Fixed typo in closing tag"),
                (r'</Opinionss>', '</Opinions>', "Fixed double-s in closing tag"),
                (r'</O[^>]*pinions?>', '</Opinions>', "Fixed malformed O-pinions tag"),
                (r'</Opini[^>]*>', '</Opinions>', "Fixed truncated Opinions tag"),
                (r'</Opin[^>]*>', '</Opinions>', "Fixed malformed Opin tag")
            ]
            
            for pattern, replacement, description in malformed_patterns:
                if re.search(pattern, line):
                    fixed_line = re.sub(pattern, replacement, line)
                    if fixed_line != line:
                        actions.append(RepairAction(
                            line_number=i + 1,
                            action_type="Fix malformed closing tag",
                            before=line,
                            after=fixed_line,
                            description=description
                        ))
                        line = fixed_line
                        line_modified = True
                        break
            
            # Fix malformed attributes
            if ' a category=' in line:
                fixed_line = line.replace(' a category=', ' category=')
                actions.append(RepairAction(
                    line_number=i + 1,
                    action_type="Fix malformed attribute",
                    before=line,
                    after=fixed_line,
                    description="Fixed 'a category=' to 'category='"
                ))
                line = fixed_line
                line_modified = True
            
            # Fix missing spaces in attributes
            missing_space_match = re.search(r'="([^"]*)"([a-zA-Z])', line)
            if missing_space_match:
                fixed_line = re.sub(r'="([^"]*)"([a-zA-Z])', r'="\1" \2', line)
                actions.append(RepairAction(
                    line_number=i + 1,
                    action_type="Fix missing attribute space",
                    before=line,
                    after=fixed_line,
                    description="Added missing space between attributes"
                ))
                line = fixed_line
                line_modified = True
            
            # Remove orphaned closing tags - disabled to prevent removing valid SemEval XML structure
            # NOTE: These patterns were too aggressive and removed valid closing tags
            orphaned_patterns = []
            
            for pattern, description in orphaned_patterns:
                if re.match(pattern, line):
                    actions.append(RepairAction(
                        line_number=i + 1,
                        action_type="Remove orphaned tag",
                        before=line,
                        after="[REMOVED]",
                        description=f"Removed {description}"
                    ))
                    i += 1
                    continue
            
            # Fix invalid XML characters
            invalid_chars = re.findall(r'[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]', line)
            if invalid_chars:
                fixed_line = re.sub(r'[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]', '', line)
                actions.append(RepairAction(
                    line_number=i + 1,
                    action_type="Remove invalid characters",
                    before=line,
                    after=fixed_line,
                    description=f"Removed invalid XML characters: {invalid_chars}"
                ))
                line = fixed_line
                line_modified = True
            
            modified_lines.append(line)
            i += 1
        
        return '\n'.join(modified_lines), actions
    
    def reconstruct_xml_structure(self, content: str) -> Tuple[str, List[RepairAction]]:
        """Advanced structural reconstruction with detailed tracking"""
        actions = []
        lines = content.splitlines()
        reconstructed = []
        
        # State tracking for proper nesting
        in_reviews = False
        in_review = False
        in_sentences = False
        in_sentence = False
        in_opinions = False
        in_text = False
        
        current_review_id = None
        
        for line_num, line in enumerate(lines):
            stripped = line.strip()
            
            # Skip empty lines in problematic contexts
            if not stripped:
                if not (in_text):
                    continue
                else:
                    reconstructed.append(line)
                    continue
            
            # XML declaration and root elements
            if stripped.startswith('<?xml') or stripped == '<Reviews>':
                reconstructed.append(line)
                if stripped == '<Reviews>':
                    in_reviews = True
                continue
            elif stripped == '</Reviews>':
                # Auto-close any open tags
                if in_opinions:
                    reconstructed.append('                </Opinions>')
                    actions.append(RepairAction(
                        line_number=len(reconstructed),
                        action_type="Auto-close tag",
                        before="[Missing closing tag]",
                        after="                </Opinions>",
                        description="Auto-closed orphaned Opinions tag"
                    ))
                    in_opinions = False
                if in_sentence:
                    reconstructed.append('            </sentence>')
                    actions.append(RepairAction(
                        line_number=len(reconstructed),
                        action_type="Auto-close tag", 
                        before="[Missing closing tag]",
                        after="            </sentence>",
                        description="Auto-closed orphaned sentence tag"
                    ))
                    in_sentence = False
                if in_sentences:
                    reconstructed.append('        </sentences>')
                    actions.append(RepairAction(
                        line_number=len(reconstructed),
                        action_type="Auto-close tag",
                        before="[Missing closing tag]",
                        after="        </sentences>",
                        description="Auto-closed orphaned sentences tag"
                    ))
                    in_sentences = False
                if in_review:
                    reconstructed.append('    </Review>')
                    actions.append(RepairAction(
                        line_number=len(reconstructed),
                        action_type="Auto-close tag",
                        before="[Missing closing tag]",
                        after="    </Review>",
                        description="Auto-closed orphaned Review tag"
                    ))
                    in_review = False
                reconstructed.append(line)
                in_reviews = False
                continue
            
            # Review handling
            if '<Review rid=' in stripped:
                # Close previous review if needed
                if in_review:
                    if in_opinions:
                        reconstructed.append('                </Opinions>')
                        in_opinions = False
                    if in_sentence:
                        reconstructed.append('            </sentence>')
                        in_sentence = False
                    if in_sentences:
                        reconstructed.append('        </sentences>')
                        in_sentences = False
                    reconstructed.append('    </Review>')
                    actions.append(RepairAction(
                        line_number=len(reconstructed),
                        action_type="Auto-close previous review",
                        before="[Missing closing tag]",
                        after="    </Review>",
                        description="Auto-closed previous Review"
                    ))
                
                reconstructed.append(line)
                in_review = True
                current_review_id = re.search(r'rid="([^"]*)"', stripped)
                current_review_id = current_review_id.group(1) if current_review_id else f'line_{line_num}'
                continue
            elif '</Review>' in stripped:
                if in_opinions:
                    reconstructed.append('                </Opinions>')
                    in_opinions = False
                if in_sentence:
                    reconstructed.append('            </sentence>')
                    in_sentence = False
                if in_sentences:
                    reconstructed.append('        </sentences>')
                    in_sentences = False
                reconstructed.append(line)
                in_review = False
                current_review_id = None
                continue
            
            # Sentences block
            if '<sentences>' in stripped and in_review:
                reconstructed.append(line)
                in_sentences = True
                continue
            elif '</sentences>' in stripped:
                if in_opinions:
                    reconstructed.append('                </Opinions>')
                    in_opinions = False
                if in_sentence:
                    reconstructed.append('            </sentence>')
                    in_sentence = False
                reconstructed.append(line)
                in_sentences = False
                continue
            
            # Individual sentences
            if '<sentence id=' in stripped:
                # Only allow inside sentences block
                if not in_sentences:
                    actions.append(RepairAction(
                        line_number=line_num + 1,
                        action_type="Skip orphaned sentence",
                        before=stripped[:100] + ("..." if len(stripped) > 100 else ""),
                        after="[REMOVED]",
                        description=f"Skipped orphaned sentence at line {line_num + 1}"
                    ))
                    continue
                
                # Close previous sentence
                if in_sentence:
                    if in_opinions:
                        reconstructed.append('                </Opinions>')
                        in_opinions = False
                    reconstructed.append('            </sentence>')
                    actions.append(RepairAction(
                        line_number=len(reconstructed),
                        action_type="Auto-close previous sentence",
                        before="[Missing closing tag]",
                        after="            </sentence>",
                        description="Auto-closed previous sentence"
                    ))
                
                reconstructed.append(line)
                in_sentence = True
                continue
            elif '</sentence>' in stripped:
                if in_opinions:
                    reconstructed.append('                </Opinions>')
                    in_opinions = False
                reconstructed.append(line)
                in_sentence = False
                continue
            
            # Text content
            if '<text>' in stripped and in_sentence:
                reconstructed.append(line)
                in_text = True
                continue
            elif '</text>' in stripped:
                reconstructed.append(line)
                in_text = False
                continue
            
            # Opinions
            if '<Opinions>' in stripped and in_sentence:
                reconstructed.append(line)
                in_opinions = True
                continue
            elif '</Opinions>' in stripped:
                reconstructed.append(line)
                in_opinions = False
                continue
            
            # Opinion entries
            if '<Opinion target=' in stripped and in_opinions:
                reconstructed.append(line)
                continue
            
            # Regular text content
            if in_text or (in_sentence and not in_opinions and '<' not in stripped):
                reconstructed.append(line)
                continue
            
            # Skip orphaned content
            if not (in_reviews and in_review):
                actions.append(RepairAction(
                    line_number=line_num + 1,
                    action_type="Skip orphaned content",
                    before=stripped[:100] + ("..." if len(stripped) > 100 else ""),
                    after="[REMOVED]",
                    description="Skipped orphaned content outside proper structure"
                ))
                continue
            
            # Default: keep line if in proper context
            reconstructed.append(line)
        
        # Final cleanup - ensure proper closure
        if in_opinions:
            reconstructed.append('                </Opinions>')
            actions.append(RepairAction(
                line_number=len(reconstructed),
                action_type="Add final closure",
                before="[Missing closing tag]",
                after="                </Opinions>",
                description="Added final Opinions closure"
            ))
        if in_sentence:
            reconstructed.append('            </sentence>')
            actions.append(RepairAction(
                line_number=len(reconstructed),
                action_type="Add final closure",
                before="[Missing closing tag]",
                after="            </sentence>",
                description="Added final sentence closure"
            ))
        if in_sentences:
            reconstructed.append('        </sentences>')
            actions.append(RepairAction(
                line_number=len(reconstructed),
                action_type="Add final closure",
                before="[Missing closing tag]",
                after="        </sentences>",
                description="Added final sentences closure"
            ))
        if in_review:
            reconstructed.append('    </Review>')
            actions.append(RepairAction(
                line_number=len(reconstructed),
                action_type="Add final closure",
                before="[Missing closing tag]",
                after="    </Review>",
                description="Added final Review closure"
            ))
        if in_reviews:
            reconstructed.append('</Reviews>')
            actions.append(RepairAction(
                line_number=len(reconstructed),
                action_type="Add final closure",
                before="[Missing closing tag]",
                after="</Reviews>",
                description="Added final Reviews closure"
            ))
        
        return '\n'.join(reconstructed), actions
    
    def create_repair_log(self, file_path: str, repair_stats: RepairStats) -> str:
        """Create detailed repair log file"""
        log_path = file_path.replace('.xml', '_repair_log.txt')
        
        with open(log_path, 'w', encoding='utf-8') as f:
            f.write("=" * 80 + "\n")
            f.write("XML REPAIR LOG\n")
            f.write("=" * 80 + "\n")
            f.write(f"File: {os.path.basename(file_path)}\n")
            f.write(f"Repair Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"Original Size: {repair_stats.original_size:,} characters\n")
            f.write(f"Repaired Size: {repair_stats.repaired_size:,} characters\n")
            f.write(f"Size Change: {repair_stats.repaired_size - repair_stats.original_size:+,} characters\n")
            f.write(f"Repair Success: {'✅ YES' if repair_stats.success else '❌ NO'}\n")
            f.write(f"Backup Created: {repair_stats.backup_path}\n")
            f.write("\n")
            
            # Corruption patterns detected
            f.write("CORRUPTION PATTERNS DETECTED:\n")
            f.write("-" * 40 + "\n")
            total_issues = sum(repair_stats.corruption_patterns.values())
            f.write(f"Total Issues: {total_issues}\n")
            for pattern, count in repair_stats.corruption_patterns.items():
                if count > 0:
                    f.write(f"  {pattern}: {count}\n")
            f.write("\n")
            
            # Detailed repair actions
            f.write("DETAILED REPAIR ACTIONS:\n")
            f.write("-" * 40 + "\n")
            f.write(f"Total Actions: {len(repair_stats.repair_actions)}\n\n")
            
            for i, action in enumerate(repair_stats.repair_actions, 1):
                f.write(f"Action {i:3d}: {action.action_type}\n")
                f.write(f"Line:        {action.line_number or 'N/A'}\n")
                f.write(f"Description: {action.description}\n")
                f.write(f"Before:      {repr(action.before)}\n")
                f.write(f"After:       {repr(action.after)}\n")
                f.write("-" * 40 + "\n")
        
        return log_path
    
    def repair_file(self, file_path: str, create_backup: bool = True) -> RepairStats:
        """Comprehensive file repair with logging and backup"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except UnicodeDecodeError:
            # Try different encodings
            for encoding in ['latin1', 'cp1252', 'utf-16']:
                try:
                    with open(file_path, 'r', encoding=encoding) as f:
                        content = f.read()
                    break
                except UnicodeDecodeError:
                    continue
            else:
                return RepairStats(0, 0, {}, [], False, None, None)
        
        original_size = len(content)
        corruption_patterns = self.detect_corruption_patterns(content)
        total_issues = sum(corruption_patterns.values())
        
        all_actions = []
        backup_path = None
        
        # Always create backup
        if create_backup:
            backup_path = file_path + '.original_backup'
            import shutil
            shutil.copy2(file_path, backup_path)
        
        # Apply basic fixes first
        content, basic_actions = self.fix_basic_corruption(content)
        all_actions.extend(basic_actions)
        
        # Apply structural reconstruction if needed
        if total_issues > 0 or corruption_patterns.get('unmatched_sentences', 0) > 0:
            content, struct_actions = self.reconstruct_xml_structure(content)
            all_actions.extend(struct_actions)
        
        # Write repaired content
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
        except Exception as e:
            return RepairStats(original_size, len(content), corruption_patterns, all_actions, False, backup_path, None)
        
        # Validate result
        try:
            ET.parse(file_path)
            success = True
        except ET.ParseError as e:
            success = False
        
        # Create repair stats object
        repair_stats = RepairStats(
            original_size=original_size,
            repaired_size=len(content),
            corruption_patterns=corruption_patterns,
            repair_actions=all_actions,
            success=success,
            backup_path=backup_path,
            log_path=None
        )
        
        # Create repair log
        if all_actions:  # Only create log if repairs were made
            log_path = self.create_repair_log(file_path, repair_stats)
            repair_stats.log_path = log_path
        
        return repair_stats